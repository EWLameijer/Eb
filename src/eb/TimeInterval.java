package eb;

import java.io.Serializable;
import java.time.Duration;
import java.util.Objects;

import org.checkerframework.checker.initialization.qual.UnknownInitialization;
import org.checkerframework.checker.nullness.qual.EnsuresNonNull;

/**
 * The TimeInterval class stores a time interval, for example "3.5 hours". It
 * stores the scalar ("3.5") and the unit ("hours") separately. (note that
 * "3.5 hours" is a quantity, "hours" is the unit. Not sure how 3.5 would be
 * called here, calling it a scalar is the best I can think of right now).
 *
 * @author Eric-Wubbo Lameijer
 */
public class TimeInterval implements Serializable {

	// Serial version UID, generated by default. Can be ignored for now.
	private static final long serialVersionUID = 4957903341568456588L;

	// The "3.5" in "3.5 hours". Indicates how many of the specified unit go in
	// the duration of this time interval.
	double m_scalar;

	// The "hours" in "3.5 hours". Indicates the unit of time used by this
	// interval.
	TimeUnit m_unit;

	/**
	 * TimeInterval constructor, creates the TimeInterval object as being of
	 * length 'scalar units' (like 2.5 minutes).
	 *
	 * @param scalar
	 *          the scalar indicating how many of the units fit in the duration of
	 *          this time interval. The "2.5" from "2.5 minutes"
	 * @param unit
	 *          the unit of this time interval, like second, hour or minute
	 */
	TimeInterval(double scalar, TimeUnit unit) {
		// preconditions: handled by setTo
		setTo(scalar, unit);
		// postconditions: handled by setTo
	}

	/**
	 * Copy constructor, useful for initializing a new TimeInterval object with an
	 * old one, without being dependent of the original object staying the same.
	 *
	 * @param intervalToBeCopied
	 *          the interval of which the values must be copied to the new
	 *          instance of TimeInterval
	 */
	TimeInterval(TimeInterval intervalToBeCopied) {
		// preconditions: the input interval should not be null
		Utilities.require(intervalToBeCopied != null,
		    "TimeInterval(TimeInterval) error: the time interval to be copied "
		        + "should not be null");
		setTo(intervalToBeCopied.m_scalar, intervalToBeCopied.m_unit);
		// postconditions: none. Simple copy, should go okay.
	}

	/**
	 * Returns the time unit of this time interval (for example the enumeration
	 * corresponding to "HOUR").
	 *
	 * @return the unit (like DAY) of this time interval object
	 */
	TimeUnit getUnit() {
		// preconditions: none: constructor should have taken care of validity
		// of the contents of this time interval.
		return m_unit;
		// postconditions: none. Simply a getter, should not change anything.
	}

	/**
	 * Returns the scalar value of the time interval (the "3.5" in "3.5 days").
	 *
	 * @return the scalar value of the TimeInterval object (the "3.5" in
	 *         "3.5 days")
	 */
	double getScalar() {
		// preconditions: none: constructor should have taken care of validity
		// of the contents of this time interval.
		return m_scalar;
		// postconditions: none. Simply a getter, should not change anything.
	}

	/**
	 * Initializes the TimeInterval object using the given values.
	 *
	 * @param scalar
	 *          the scalar indicating how many of the units fit in the duration of
	 *          this time interval. The "2.5" from "2.5 minutes"
	 * @param unit
	 *          the unit of this time interval, like second, hour or minute
	 */
	@EnsuresNonNull({ "m_scalar", "m_unit" })
	private void setTo(
	    @UnknownInitialization(TimeInterval.class) TimeInterval this,
	    double scalar, TimeUnit unit) {
		// preconditions: the scalar should be greater than 0, and the TimeUnit
		// should have been properly initialized (so not be null).
		Utilities.require(scalar >= 0, "TimeInterval.setTo() error: "
		    + "negative time intervals are not permitted.");
		Utilities.require(unit != null, "TimeInterval.init() error: "
		    + "the unit of time has not been properly initialized yet.");

		m_scalar = scalar;
		m_unit = unit;
		// postconditions: none. Should have worked.
	}

	public boolean equals(Object otherObject) {
		if (this == otherObject) {
			return true;
		} else if (otherObject == null) {
			return false;
		} else if (getClass() != otherObject.getClass()) {
			return false;
		} else {
			TimeInterval otherInterval = (TimeInterval) otherObject;
			return (m_scalar == otherInterval.m_scalar)
			    && (m_unit == otherInterval.m_unit);
		}
	}

	public int hash() {
		return Objects.hash(m_scalar, m_unit);
	}

	public Duration asDuration() {
		Duration unitDuration = m_unit.getDuration();
		return Utilities.multiplyDurationBy(unitDuration, m_scalar);
	}

}
