-Flow
-Glossary (domain knowledge, and what means what)
-HowTo (bepaalde veranderingen doorvoeren)
-Map (where the data is) => Just for classes
-Design
-Problems & Ideas (things that we may want to change)


General change framework

1. Change 
2. Errors
3. Sweep [changes] // git diff / check
4. Test
5. Commit

Now at status: ?.?


Flow

*Starting Eb*

The program start shows Eb's main window. This window either shows a random card of the current deck to be studied, or, if there are no cards to be studied, a text indicating Eb's basic commands as well as some statistics on the current deck, like its size.

*Doing things with Eb*

There are some things you can always do with Eb, and other things that you can only do when there are cards to be studied.

The 'general things':

-Saving the current status & quitting Eb: Ctrl-Q, or, in the menu bar, File->Quit.

-Adding a card: Ctrl-N, or, in the menu bar, Manage Deck->Add Card. More on adding cards in the section "*Adding cards*"

-Displaying the study options menu: Ctrl-T. More on the study options menu in the section "The Study Options Menu"


*Adding Cards*

Pressing "Ctrl-N" will open a card adding frame. This frame will be closed (without saving its data), by pressing 'escape' or clicking on the Cancel button. But most of the time, of course, you will want to use it to add cards. 

Adding cards is easy: you type in text in the top field (this is the 'front' of the card, which will be shown as the question/cue when you review the cards). Then you either click on the field below, or, more conveniently, press <Enter> if you are done filling in the text on the front. This will allow you to fill in the text for the back of the card, the 'answer'. When you are done, either press the "OK" button or simply press <Enter> again to add the new card to the collection.

Note that if the front of the card is empty, or a duplicate of the front of another card, Eb will complain and refuse to add the card until the front has some contents and is unique. *@view duplicate-functionality?*


*The Study Options Menu*

Each learner is unique, and so is the structure and difficulty of each deck. For example, when learning the capitals of the American states, you can easily review them 10 hours later after first adding the card. For studying say Russian vocabulary, 5 or 10 minutes may be a more appropriate time for the first repetition. In the Study Options menu you can set such deck characteristics to values that fit the deck and your preferred style of study. It even allows you to experiment with different study methods!

The first parameter you can set is the "Initial interval", which is the time Eb lets pass after you added the card before it presents the card to you for the first review. If the deck is hard, you may want to choose 10 minutes; for an easy deck, 3 hours or even one day would be appropriate. The rule of thumb is that you should be able to answer between 80% and 95% of cards correctly at a repetition. *@Eb gives feedback?*



%%% For programmers %%%

% Starting Eb %

Eb is started by invoking the main() method of the MainWindow() class.

% Design %

Most of Eb is rather straightforward: windows that pop up, listeners to UI elements, and so on.

The things I'm currently struggling with with Eb involve two aspects:
1) serialization/deserialization
2) the architecture of the Deck-object.

% Serialization %

Serialization: having been involved in maintaining software that has 'backward compatibility challenges', and also because (if successful) Eb will grow, getting a proper format for serializing data will be very handy. The ideal serialization solution would be:
a) very maintainable (so backward compatibility ensured without huge reams of "if (versionNumber<...)" statements)
b) minimizes boilerplate code.

Currently, Eb uses Java serialization which is very 'unboilerplaty' to program, but not maintainable (you can throw away each deserialized object as soon as you add a field somewhere - okay, that is not entirely true, you can add new fields, but you need to keep the serializion ID the same then, which may not be that good an idea).
What should really happen with Eb's serialization:
You have an object (or a collection of objects). Each object has a number of properties (say: key-value pairs).
When reading an object from file, fill in the member variables based on the names. If there is no key corresponding to the member variable, try recreate its value as best you can (for example: has they key been renamed? Can it be deduced from other data? Or should it just be initialized to a default value?).
Basically, you want to store and read a (nested) map, that you can update intelligently, or at least .
While it is of course possible to homebrew your own format, using some standard notation/parsers can save lots of maintenance work, especially as I don't consider it my core business to invent improved data serialization formats. 

The most common formats that are available for serialization/deserialization:
XML
JSON
YAML
Google Proto 
BSON

Any of these formats would be okay; they differ in human-readableness (YAML>JSON>XML | GProto and BSON not) and efficiency (GProto likely best, followed by BSON). My current decision is to first get Eb working decently, and if it is successful/changing enough to warrant a better serialization system, switch to Google proto. If debugging turns out to be the main problem, I'll link to a YAML library first.

% The architecture of the Deck object %

What is a Deck? Purely logically, a deck is a set of cards, each of which have their front and back and revision history. In practice, however, this is only true for an abstract (and fresh) deck. A deck, if things go right, becomes a tool to be shaped to the learner's mind, both by keeping records on each card of how well it has been remembered, as well as generic deck settings (the interval between the creation of the card and the first time it should be shown is likely different between a Java deck and a Russian deck). In principle, these data are separable; in practice, it's more convenient to store the deck settings and learning history of the deck together with the logical contents of the cards.

At a certain time, Eb can only have a single active deck. This suggests some constraint on the number of Deck objects that one can create at a time; a singleton pattern or monostate pattern jump to mind, or even a static class. None of those options look particularly appealing at this time; monostate is misleading, suggesting that one can create multiple independent objects while in reality all data is shared; a static class is (at the moment) pragmatically impossible because that doesn't work with serialization, and a singleton pattern, while 'correct', introduces the boilerplate .getInstance() everywhere. Another problem is that the 'logical' deck should have some kind of interaction with the GUI - interactions that are not part of the logical contents of the deck (if a new deck is loaded, it should not need to learn about how to update the GUI). For this reason, I created a static "Deck" class that contains a pointer to the logical deck (a regular class called 'LogicalDeck'. The Deck is kind of like the office manager, forwarding content-related calls to the LogicalDeck, and handling the messy work of interacting with the GUI, so the GUI elements are all anchored in the Deck, and things don't have to change when the logical deck is swapped (say from Java to Japanese).

This approach has some drawbacks, mainly that many Deck functions are kind of 'middleman' functions and most require checks to ensure the validity/existence of the logical deck, but, barring further insights, this seems the least bad solution at the moment. 




 



The Study Options window reads values from (and sets) StudyOptions objects. The StudyOptions class has a getDefault factory method, which calls the private constructor, setting all options to their default values. It also has data members like m_initialInterval which contain the length of the interval between creating the card and the first required review. Of course, Eb has default values for the initial interval (DEFAULT_INITIAL_INTERVAL). The TimeInterval values are assigned using constructors, copy constructor and init, getUnit() and getScalar() return the unit (like HOUR of "3 hours") and the scalar (the 3 of "3 hours") respectively. And StudyOptions adds the "getInitialInterval" to access its data.

GUI-wise, the doubleToMaxPrecisionString is used to create the numbers in the right format (max 2 places of precision)
***Return to deck's current settings - extra button




Glossary

-Card: one of the cards that is studied. A card has contents (front and back, 'stimulus' and 'response', as well as a history (number of repetitions and failure rate and such).
-Deck: a collection cards that can be studied
-Study Options: the collection of options that determines how a SRS deck is to be studied, for example the interval before the first repetition, how much the study interval should increase upon success, whether there is a maximum time the student has before he or she may answer, and so on.

HowTo

-Check whether a string is null or empty: Utilities.isStringNullOrEmpty
-Check whether a string is a valid identifier/token: Utilities.isStringValidIdentifier
-Check whether an error has occurred which has to lead to program end (or a warning!) Utilities.require
-Check whether the user has pressed Escape and therefore the cancel button needs to be pressed: EscapeKeyListener (inner class in NewCardWindow)
-Check whether the user has pressed Enter and therefore (for example) the ok-button needs to be pressed: EnterKeyListener (inner class in NewCardWindow)
-Change a component (especially a text-containing component) so that tab and possibly enter won't influence the text, but will cause the focus to shift: Utilities.makeTabTransferFocus and Utilities.makeTabAndEnterTransferFocus  
-Add a system-specific line break: Utilities.EOL

Coding style: 
	*exceptions: if you use "Pokemon exception handling" ('catch (Exception e)'), add e.printStackTrace(); [ERROR 1]
	*require: Class.methodName() error: message. If constructor: Class() or Class(Type[,Type]). Example Utilities.require(Utilities.isStringValidIdentifier(deckName), "Deck.getDeckFileHandle() error: deck name is invalid.");

Construct a class 

Construct a method [CPPCCC]
	-preconditions
			-parameters
			-global settings?



Map
-DeckChangeListener: an interface for objects that need to know when the contents of the current deck has been changed; it is a functional interface, containing only one method, respondToChangedDeck
-Deck: THE deck used by Eb, basically a wrapper for the current deck (like "Chinese.deck") which is a LogicalDeck object. Has contents (m_contents) and contains the name of the deck that should be loaded by default (called "default")
-LogicalDeck: a (logical) deck, with a name and a list of cards
-Extension: the extension of a deck file (".deck") is called DECKFILE_EXTENSION found in the DECK class
-Utilities: contains all kinds of things that are not domain specific
-MainWindow: the main window of the application
-NewCardWindow: a window in which the user can create a new card, which is to be added to the deck.
-StudyOptions: the collection of options that determines how a SRS deck is to be studied, for example the interval before the first repetition, how much the study interval should increase upon success, whether there is a maximum time the student has before he or she may answer, and so on.
-StudyOptionsWindow: a window in which the user can set the study options, like the intervals to be used.
-TimeInputElement: a UI-element that allows users to see (or set) a time, like "0.1 seconds" or "3 day(s)"
-TimeInterval: stores a time interval, like 3 hours (the 3 can be a double) Contains a m_scalar (the 3.5 from 3.5 hours) and a m_unit (the hour from 3.5 hours), which are set by the constructor (which also requires time intervals to have length > 0)
-TimeUnit: enum of times, of SECOND, MINUTE. Stores both string names ("second(s)") [m_name] and time value (Durations) [m_duration]

Design
1) Create a window called "Eb", and display the commands as well as the number of cards in the currently loaded deck => Jan 9th, 2016
2) Create a menu containing a Save and Quit-button, allow it to be activated by pressing 'Ctrl-Q', and make it work to quit Eb => Jan 10th, 2016
3) Create a Ctrl-N item that produces a window that allows the user to add a new card to the current deck  => Feb 8th, 2016
5) Allow reviewing cards [add option window to set interval]
	a) Add a Ctrl+T option to the help label, that there is also an option window Feb 8 2016
	b) Add a menu option, including Ctrl+T  Feb 8 2016
	c) let Ctrl+T from menu or shortcut open the Study Options window. Feb 8 2016
	d) Give the study options window a label, a textbox, and a combobox (sec...years) Feb 8 2016
	e) Add buttons: back to study, reset to default, set study settings to this  Feb 9 2016
	f) Ensure the cancel button works Feb 9 2016
	g) Ensure the default button works Feb 16 2016
	g2) check all code and documentation. (Feb round, +28 days RtM)
	h) Add the mention of a third option (Ctrl-T) to the Main window March 28 2016
	h) Ensure the save button works (implement a Study Settings object and data member in DeckContents) March 28 2016
	i) Ensure that the cancel button reads 'discard unsaved changes' March 28 2016 
	j) Make 'changes saved'- 'changes unsaved' part of the StudyOptions window
	
	// timed? bool and timedinterval
	5) Add the possibility to review cards
	g) make the main window show the time till review of the first card (in seconds [clock])
	h) Ensure that the main window, upon loading and in a cycle of 1 minute checks whether there are reviewable cards, loads these into a 'batch'
	i) Make main-window in review mode (know - don't know)
	j) after reviewing the batch, checking again whether there are new cards to review, calling that the next batch.
	k) add option for failed cards - rotating batch or stew (option minutes)
6) Add repetition schedule (absolute constant 1 day, relative factor X [absolute custom later?])
7) Eb and git: make the Git-dir contain Eclipse-dir (so with root and class). Add executable JAR (and test it somewhere)



Card	
	Card(String, String)
	getFront()
	getBack()
	
Deck 
	addCard()
	addDeckChangeListener()
	canAddCard()
	createDeckWithName()
	deckHasBeenLoaded()
	ensureDeckExists()
	getCardCount()
	getStudyOptions()
	loadDeck()
	notifyOfDeckChange()
	save()
	
DeckChangeListener
	[]respondToChangedDeck()
	
LogicalDeck
	addCard()
	canAddCard()
	getCardCount()
	getDeckFileHandle()
	getFileHandle()
	getStudyOptions
	isNotYetPresentInDeck()
	LogicalDeck()
	
MainWindow
	.respondToChangedDeck()
	getUICommands()
	getDeckSizeMessage()
	updateMessageLabel()
	openStudyOptionsWindow()
	MainWindow()
	saveAndQuit()
	openNewCardWindow()
	#main()
	
NewCardWindow
	EnterKeyListener
		keyPressed()
		keyReleased()
		keyTyped()
	EscapeKeyListener
		keyPressed()
		keyReleased()
		keyTyped()
	close()
	submitCandidateCardToDeck()
	NewCardWindow()
	init()
	display()
	
StudyOptions
	getInitialInterval()
	StudyOptions()
	getDefault()
	
StudyOptionsWindow
	close()
	loadEbDefaults()
	loadCurrentDeckSettings()
	StudyOptionsWindow()
	init()
	showStudyOptionsWindow()

TimeInputElement
	getInterval()
	setInterval()
	TimeInputElement()

TimeInterval
	getUnit()
	getScalar()
	init()
	TimeInterval()
	TimeInterval(TimeInterval)
	
TimeUnit
	TimeUnit()
	getUserInterfaceName()
	getUnitNames()
	
Utilities
	EOL
	isStringValidIdentifier()
	require()
	makeTabTransferFocus()
	makeTabAndEnterTransferFocus()
	doubleToMaxPrecisionString()
	
	
	


Problems & Ideas
Problem 1: DeckManager.getInstance().getCurrentDeck().getCardCount() is ugly
Problem 2: Hard to undo changes, no version control yet.
Problem 3: I have to ensure that whenever I create or load a deck, it gets the MainWindow as listener for DeckChangeEvents. Okay. may need to make the deck a singleton.
Problem 4: who should take the responsibility for giving the filehandle? I guess the DeckContents, as that has the name.
Problem 5: Can I factor out the close operations?
Problem 6: fundamentally, the DeckContents have study options,

Problem 1 -
Option 1: If I make Deck a singleton class I get
	Deck.getInstance().getCardCount(), which is at least a bit better
Option 2: If I make Deck a static class, I get 
	Deck.getCardCount(), which is what I want. However, this has two disadvantages:
	1) I can't use serialization/deserialization anymore for load/save, as my data members are static now. This is very annoying!
		This could be solved with Google Proto, database calls or XML creation, but each takes a few hours to master sufficiently. Parsing/deparsing
		is also possible, but is not very maintainable and will incur continuous overhead.
	2) as I won't be returning 'Deck' and such, it is harder to indicate success and failure of something. I mean: I can throw exceptions
	   if a deck is not found, but you shouldn't use exceptions for normal program behaviour. I can give a return value, but return values
	   can happily be ignored, especially if they don't contain vital information (like the Deck). I can give 'success' as a second argument, but
	   while that may be harder to ignore, Java passes by value and wrapping something in an boolean object seems overkill. I can use a 'canLoadDeck' 
	   function, and barf an assert/runtime crash if it is not used properly, but needing to define an extra function for every function 
	   that can legally fail is also not elegant.
Option 3: I can make DeckManager 'wrapping' functions, so DeckManager.getCardCount() calls the full DeckManager.getInstance().getCurrentDeck().getCardCount() 
	However, this is ugly as it leads to interface duplication, wrapping all Deck's methods in 
	
Ideas
Sanitize the front and deck, removing leading and lagging whitespace?
Better error message; either front or duplicate.

