Eb+22+30(do21/1) [1/5 voor rest]


-Flow
-Glossary (domain knowledge, and what means what)
-HowTo (bepaalde veranderingen doorvoeren)
-Map (where the data is) => Just for classes
-Design
-Problems & Ideas (things that we may want to change)


4f OK

5
Change 
Errors
Sweep [changes]
Test
Commit



Changes:

Flow

*Starting Eb*
-Start the program
Invoke the main() method of MainWindow, which calls the MainWindow constructor to construct the window itself.
This shows a frame, with the PROGRAM_NAME as its name.
The main window - if there are no cards to be studied - contains a text describing the GUI shortcuts (provided by getUICommands) as well as the deck size provided by getDeckSizeMessage. The label containing this is called m_messageLabel.
How do you decide whether there are cards to be studied? By looking at the deck. Unless otherwise specified, Eb loads the deck with the DEFAULT_DECKNAME (which is "default.deck") at the first call of a public Deck method (which calls deckExists(), which ensures that the deck indeed exists, or otherwise quits the program in a horrible way ;)). deckHasBeenLoaded is a nice utility function to encapsulate the low level ==null calls. This loading simply happens by looking for the deck file, which simply is the deck's name with the extension ".deck" (which is encoded in DECKFILE_EXTENSION). Anyway, Deck.loadDeckWithName loads the file.
But what if the file does not exist yet? Then Deck.createDeckWithName is called.
What these actually do: Deck is a kind of wrapper that is 'THE' deck of Eb, the target and anchor of all GUI elements. The contents are simply a static pointer in the Deck class (m_contents) pointing to a DeckContents object
Then a deck is created, with Deck.m_name set to the name. getFileHandle / 
getDeckFileHandle are used to transform a deck name to the name of the deck 
file. The getCurrentDeck() of MainWindow gets this deck, sysexit with error if 
it is unloadable.
The decksize is found with getCardCount. This looks at the m_cards list of 
cards, and returns their count.
Quitting calls MainWindow.saveAndQuit, which saves the deck (with Deck.save) 
before exiting Eb.

*Adding cards to the currently active deck*
Creating a new card opens the NewCardWindow (using the function originally called "openNewCardWindow"). This window has panels (m_frontOfCard and m_backOfCard) to create the contents of the front and back.
The NewCardWindow also has a cancel button (m_cancelButton) to cancel the creation of the card and get back to the main/calling window (this happens using the "close" function, and an OK button which the user can press to add the created card to the current deck - or at least try to, the card may be a duplicate or invalid for some reason. The NewCardWindow also has utility classes, like EscapeKeyListener with its keyPressed method, which checks of every keypress whether it presses 'escape', and if it does, closes the frame (works the same as pressing the cancel button). The EnterKeyListener is similar, but in this case it is attached to the back of the card and activates the OK-button (after all, if the user has completed the back of the card, he probably wants to press enter to save it).
How to save a card? Well, the NewCardWindow creates a Card (using the Card constructor, which fills m_frontOfCard and m_backOfCard) and submits it to the current deck (getting access to the central deck point using DeckManager.getInstance(), which has of course the m_instance
as the pointer to the sole instance of the class, as per the Singleton pattern). 
Anyway, the 'submitCandidateCardToDeck' method is called, which checks the front and back of the card, retrieving them via the getFront() and getBack() methods. It checks, using the method canAddCard whether the front of the card is both valid and really new (isNotYetPresentInDeck) and whether the back of the card is also okay. If everything is okay, the "addCard" method is called and the card is inserted into the deck, and the textboxes are emptied to make room for new input for the new card. If not, a warning is displayed.
Anyway, if a card is added, the DeckChangeListeners are activated (their respondToChangedDeck functions are called) by the notifyOfDeckChange method in Deck; in the MainWindow this causes the updateMessageLabel to be called (this has been enabled by registering the MainWindow to listen to changes in the deck with the Deck.addDeckChangeListener() method.

*Checking/setting the study options of a deck*
Pressing Ctrl+T opens the study options window via the openStudyOptionsWindow method in the MainWindow. In it are an option to set the length of the first study interval. This length can be edited in the UI at the place labeled by the label m_initialIntervalLabel, by providing the "3 hours" in the m_initialIntervalBox TimeIntervalElement, which stores the quantity (3 of 3 hours) in a textfield m_scalarField, and the unit (the hours in "3 hours") in the combobox m_unitComboBox, which gets its values from TimeUnit.getUserInterfaceName() [the full choice of values come from TimeUnit.getUnitNames).
This window also has some buttons: the Cancel-button (m_cancelButton) which calls the close function, the button that load the default values of Eb (the m_loadEbDefaultsButton), the button that reloads the current deck settings (m_loadCurrentDeckSettingsButton, using the loadCurrentDeckSettings method ) and the button that sets the options of the this Deck (like Chinese) to the given values, m_setToTheseValuesButton.
The close function is easy. Setting the values to Eb's defaults requires Eb's defaults to be stored somewhere. This requires a kind of standardStudyOptions, being an instance of the StudyOptions class.

The Study Options window reads values from (and sets) StudyOptions objects. The StudyOptions class has a getDefault factory method, which calls the private constructor, setting all options to their default values. It also has data members like m_initialInterval which contain the length of the interval between creating the card and the first required review. Of course, Eb has default values for the initial interval (DEFAULT_INITIAL_INTERVAL). The TimeInterval values are assigned using constructors, copy constructor and init, getUnit() and getScalar() return the unit (like HOUR of "3 hours") and the scalar (the 3 of "3 hours") respectively. And StudyOptions adds the "getInitialInterval" to access its data.

GUI-wise, the doubleToMaxPrecisionString is used to create the numbers in the right format (max 2 places of precision)
***Return to deck's current settings - extra button




Glossary

Card: one of the cards that is studied. A card has contents (front and back, 'stimulus' and 'response', as well as a history (number of repetitions and failure rate and such).
Deck: a collection cards that can be studied
Study Options: the collection of options that determines how a SRS deck is to be studied, for example the interval before the first repetition, how much the study interval should increase upon success, whether there is a maximum time the student has before he or she may answer, and so on.

HowTo

Check whether a string is null or empty: Utilities.isStringNullOrEmpty
Check whether a string is a valid identifier/token: Utilities.isStringValidIdentifier
Check whether anSS error has occurred which has to lead to program end (or a warning!) Utilities.require
Check whether the user has pressed Escape and therefore the cancel button needs to be pressed: EscapeKeyListener (inner class in NewCardWindow)
Check whether the user has pressed Enter and therefore (for example) the ok-button needs to be pressed: EnterKeyListener (inner class in NewCardWindow)
Change a component (especially a text-containing component) so that tab and possibly enter won't influence the text, but will cause the focus to shift: Utilities.makeTabTransferFocus and Utilities.makeTabAndEnterTransferFocus  

Coding style: 
	*exceptions: if you use Pokemon exception handling, add e.printStackTrace(); [ERROR 1]
	*require: Class.methodName error: message. If constructor: Class() or Class(Type[,Type])

Construct a class 

Construct a method [CPPCCC]
	-preconditions
			-parameters
			-global settings?

Add a system-specific line break: Utilities.EOL

Map
DeckChangeListener: an interface for objects that need to know when the contents of the current deck has been changed; it is a functional interface, containing only one method, respondToChangedDeck
Deck: THE deck used by Eb, basically a wrapper for the current deck (like "Chinese.deck") which is represented by a DeckContents object. Has contents (m_contents) and contains the name of the deck that should be loaded by default (called "default")
DeckContents: a (logical) deck, with a name and a list of cards
Extension: the extension of a deck file (".deck") is called DECKFILE_EXTENSION found in the DECK class
Utilities: contains all kinds of things that are not domain specific
MainWindow: the main window of the application
NewCardWindow: a window in which the user can create a new card, which is to be added to the deck.
StudyOptions: the collection of options that determines how a SRS deck is to be studied, for example the interval before the first repetition, how much the study interval should increase upon success, whether there is a maximum time the student has before he or she may answer, and so on.
StudyOptionsWindow: a window in which the user can set the study options, like the intervals to be used.
TimeInputElement: a UI-element that allows users to see (or set) a time, like "0.1 seconds" or "3 day(s)"
TimeInterval: stores a time interval, like 3 hours (the 3 can be a double) Contains a m_scalar (the 3.5 from 3.5 hours) and a m_unit (the hour from 3.5 hours), which are set by the constructor (which also requires time intervals to have length > 0)
TimeUnit: enum of times, of SECOND, MINUTE. Stores both string names ("second(s)") [m_name] and time value (Durations) [m_duration]

Design
1) Maak een scherm dat Eb heet
2) Zorg dat Eb's status op het scherm verschijnt => hoeveel kaarten er in het huidige deck zijn, en wat de commando's zijn om dingen te veranderen.
	-Cannot create deck. Waarom? => serialization error
	=> Finished: Zaterdag 9 januari 2016
3) Zorg dat er een menu is voor Ctrl+Q, OK 10 jan 2016
	en dat dat werkt OK 10 jan 2016
4) Zorg dat
	a) er een item is voor Ctrl+N OK 10 jan 2016
	 b) en dat dat werkt: dwz: windoowtje tonen 26 jan 2016
	c) en zorgen dat het editbare top en bodem heeft 26 jan 2016
	d) en zorgen voor OK en Cancel knoppen 26 jan 2016
	e) en zorgen dat de OK-knop de kaart naar het deck savet! 26 jan 2016
	d) en zorgen dat het de boodschap op het hoofdscherm updates 6 feb 2016
	f) en zorgen dat de OK-knop de focus weer naar de front verschuift
5) Allow reviewing cards [add option window to set interval]
	a) Add a Ctrl+T option to the help label, that there is also an option window Feb 8 2016
	b) Add a menu option, including Ctrl+T  Feb 8 2016
	c) let Ctrl+T from menu or shortcut open the Study Options window. Feb 8 2016
	d) Give the study options window a label, a textbox, and a combobox (sec...years) Feb 8 2016
	e) Add buttons: back to study, reset to default, set study settings to this  Feb 9 2016
	f) Ensure the cancel button works Feb 9 2016
	g) Ensure the default button works Feb 16 2016
	h) Ensure the save button works (implement a Study Settings object and data member in DeckContents)
	
	5) Add the possibility to review cards
	a) Add the mention of a third option (Ctrl-T) to the Main window // Ctrl-O for open, Ctrl-P 
	b) Let Ctrl-T open an options window
	c) Create an Options class, which becomes a member/property of DeckContents
	d) Add an "time before first review" label + textbox + timebox (min/hrs/days/weeks/months/years)
	e) Initialize it (programmatically) to 10 minutes
	f) Add a button 'load default settings of Eb' which resets it to 10 minutes.
	g) make the main window show the time till review of the first card (in seconds [clock])
	h) Ensure that the main window, upon loading and in a cycle of 1 minute checks whether there are reviewable cards, loads these into a 'batch'
	i) Make main-window in review mode (know - don't know)
	j) after reviewing the batch, checking again whether there are new cards to review, calling that the next batch.
	k) add option for failed cards - rotating batch or stew (option minutes)
6) Add repetition schedule (absolute constant 1 day, relative factor X [absolute custom later?])
7) Eb and git: make the Git-dir contain Eclipse-dir (so with root and class). Add executable JAR (and test it somewhere)




Problems & Ideas
Problem 1: DeckManager.getInstance().getCurrentDeck().getCardCount() is ugly
Problem 2: Hard to undo changes, no version control yet.
Problem 3: I have to ensure that whenever I create or load a deck, it gets the MainWindow as listener for DeckChangeEvents. Okay. may need to make the deck a singleton.
Problem 4: who should take the responsibility for giving the filehandle? I guess the DeckContents, as that has the name.
Problem 5: Can I factor out the close operations?
Problem 6: fundamentally, the DeckContents have study options,

Problem 1 -
Option 1: If I make Deck a singleton class I get
	Deck.getInstance().getCardCount(), which is at least a bit better
Option 2: If I make Deck a static class, I get 
	Deck.getCardCount(), which is what I want. However, this has two disadvantages:
	1) I can't use serialization/deserialization anymore for load/save, as my data members are static now. This is very annoying!
		This could be solved with Google Proto, database calls or XML creation, but each takes a few hours to master sufficiently. Parsing/deparsing
		is also possible, but is not very maintainable and will incur continuous overhead.
	2) as I won't be returning 'Deck' and such, it is harder to indicate success and failure of something. I mean: I can throw exceptions
	   if a deck is not found, but you shouldn't use exceptions for normal program behaviour. I can give a return value, but return values
	   can happily be ignored, especially if they don't contain vital information (like the Deck). I can give 'success' as a second argument, but
	   while that may be harder to ignore, Java passes by value and wrapping something in an boolean object seems overkill. I can use a 'canLoadDeck' 
	   function, and barf an assert/runtime crash if it is not used properly, but needing to define an extra function for every function 
	   that can legally fail is also not elegant.
Option 3: I can make DeckManager 'wrapping' functions, so DeckManager.getCardCount() calls the full DeckManager.getInstance().getCurrentDeck().getCardCount() 
	However, this is ugly as it leads to interface duplication, wrapping all Deck's methods in 
	
Ideas
Sanitize the front and deck, removing leading and lagging whitespace?
Better error message; either front or duplicate.

